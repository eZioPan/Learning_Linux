= SQLite 笔记
:source-language: SQL

== 特点

SQLite 是轻量化的数据库，它的最大的特点就是 serverless，也就是说，它不像 PostgreSQL 和 MongoDB 一样，在使用前需要安装和配置对应的服务器。

这样它就可以方便地作为一个软件内置的数据库而存在。

== 安装

link:https://www.sqlite.org/download.html[]

其中 `sqlite_tool` 的包，是 SQLite 官方提供的数据操纵命令行工具

== 语法

这里我们说的语法，既包含通用的 SQL 语法，又包含命令行工具 `sqlite3` 所特有的语法。

对于命令行工具特有的语法，我们使用“命令（command）”来表述 +
对于通用的 SQL 语法，我们使用“语句（statement）”来表述。

[NOTE]
====
就语法特点来说，SQL 更像是一种表达式， +
它的一个完整的操作是一次性完成的，因此一个操作的所有步骤也是在一条语句中完成的。

这并不表示 SQL 不能执行复杂的操作，相反，通过复杂的（嵌套）SQL 语句，我们可以实现任意的操作。
====

== 常见的 sqlite3 命令（command）

[IMPORTANT]
====
与 SQL 语句不同，sqlite3 命令**禁止**以分号 `;` 结尾，否则分号会作为命令的一部分被读取
====

[cols="^.^1m,^.^2,.^2a"]
.打开、关闭、读取、写入
|===
| sqlite3 命令 | 含义 | 备注

| .help [匹配文本]
| 打印含有匹配文本的**命令**的帮助
| 若不指定匹配文本，则打印所有命令的简短帮助

| .version
| 显示当前 sqlite3 的版本，以及附带组件的版本
|

| .quit
| 关闭 `sqlite3.exe` 交互
|

| .open [选项] <数据库文件>
| 将一个数据库作为 main 数据库打开 +
常用选项 +
`--readonly` 以只读方式打开数据库
| 等价于在命令行中运行 +
`sqilte3.exe <数据库文件>` +
注意，以这种方式打开的数据库，不可以被 `DETACH DATABASE` 关闭 +
但可以使用 `.open ''` 关闭，不过这样所有已经 `ATTACH` 的数据库也会被一同关闭。

d| `.backup [数据库名] <保存路径>` +
以及 +
`.save [数据库名] <保存路径>`
| 将指定的数据库保存为一个数据库文件
| 若不指定数据库名，则将 main 保存至指定文件

| .read <FILE>
| 从文件读取命令或语句，并执行
|
|===


[cols="^.^1m,^.^2,.^2a"]
.枚举相关的命令
|===
| sqlite3 命令 | 含义 | 备注

| .databases
| 显示当前打开的/连接的数据库
| 会显示数据库的名称、文件名、以及读写权限

[TIP]
====
在使用 `ATTACH DATABASE` 语句之后会很有用
====

| .tables [表名]
| 罗列匹配上的表的名称
| 若不指定表名，则罗列全部的表

[source, sqlite3]
.罗列以 es 作为表名结尾的表
----
.table '%es'
----

| .schema [表名]
| 罗列匹配上的表的架构
| 返回值均以 `CREATE` 开头，模拟了创建表的流程

| .fullschema
| 罗列全部的表架构，包含特殊的表 sqlite_stat
| 特别注意，这个命令仅对 main 数据库有效

| .indexes [表名]
| 显示特定表的索引
| 若不指定表名，则显示全部的索引

[source, sqlite3]
.罗列以 es 作为表名结尾的索引
----
.indexes '%es'
----
|===

[cols="^.^1m,^.^2,.^2a"]
.修改输出模式
|===
| sqlite3 命令 | 含义 | 备注

| .mode [显示模式]
| 设置输出的显示模式
| 没有参数时，输出当前的显示模式 +
要获得所有支持的模式，可以随便用一个字符当参数，看看输出的报错即可

| .header <on\|off>
| 打开或关闭表头的显示
|
|===

[cols="^.^1m,^.^2,.^2a"]
.输出重定向
|===
| sqlite3 命令 | 含义 | 备注

| .output [文件名]
| 修改输出的位置
| 默认为 stdout，如果设置为文件，则将输出写入指定的文件中。 +
**使用不带参数的 `.output` 可以将输出重新导向至 stdout**

| .once [文件名]
| 修改下一条 sqlite3 命令/ SQL 语句 的输出位置
|
|===

== 常见的 SQL 的语句（statement）

[IMPORTANT]
====
单行注释语句，以两个横线 `--` 开头

多行注释语句，以 `/*` 开头，以 `*/` 结尾

除了注释语句，其它的 SQL 语句**必须**以分号 `;` 结尾

（非常规的）标识符用双引号 `"` 引用， +
比如名称含有空格的列，或者将 SQLite 关键字当作名称的列，若要访问某行的该列的数据，则需要使用双引号包裹列名称

字符串字面量用单引号 `'` 引用， +
若一个双引号包裹的字符串不匹配任何标识符，那么它也会被当作字符串字面量来处理
====

=== ATTACH 语句

[source]
----
ATTACH DATABASE '<数据库文件>'' AS <名称>;
----

在同一个 sqlite3 会话中再打开一个数据库

如果 <数据库文件名> 为空（`''`），则在**内存中**创建一个数据库。

特别注意 **数据库文件名必须使用引号包裹**

`AS` 后跟随的 <名称>，是当前 sqlite3 会话中该数据库的代指。

=== DETACH 语句

[source]
----
DETACH DATABASE <数据库文件>;
----

关闭一个已经打开的数据库

=== SELECT 语句

[source]
----
SELECT ...
----

与其说 `SELECT` 是选择语句，不如说 `SELECT` 是打印语句，比如说，

[source]
----
SELECT 1+1;
----

就可以计算 1+1 的结果。

`SELECT` 主要用于查询数据库内容，最常见的语法是

[source]
----
SELECT <键名1>[,<键名2>...] FROM <表名>;
SELECT * FROM <表名>; -- 显示一个表中所有的列的值
----

比如说，

[source]
----
SELECT id, name FROM people;
----

就可以用来从 people 这个表中获取 id 键和 name 键的值。

[IMPORTANT]
====
如果指定的键名表中不存在，则 sqlite3 会返回错误

因此在实际的使用中，我们也应该避免随意地使用星号 `*` 作为键名地匹配， +
而是明确指出要访问的键，防止获得不匹配的键
====

除了基础的 `SELECT` 语句语法，`SELECT` 还支持追加其它更加复杂的语句，因此说 `SELECT` 是最复杂的 SQL 语句也不为过。

它支持追加的语句还包含

* xref:_order_by_语句[`ORDER BY`] 用于排序结果
* xref:_distinct_语句[`DISTINCT`] 仅返回互不相同的值
* xref:_where_语句[`WHERE`] 预先筛选值
* xref:_limit_offset_语句[`LIMIT OFFSET`] 限制返回行的数量
* xref:_inner_join_语句[`INNER JOIN`] 或 xref:_left_join_语句[`LEFT JOIN`] 使用 join 从多个表中获得数据
* xref:_group_by_语句[`GROUP BY`]  将返回值编组，并对每个组进行统计
* xref:_having_语句[`HAVING`] 以过滤组

=== ORDER BY 语句

[source]
----
SELECT
    ...
FROM
    ...
ORDER BY
    <键名1> [ASC], -- 正序
    [<键名2> DESC], -- 逆序
    [<键名3> NULLS LAST]; -- 将空值移动至最后
----

[IMPORTANT]
====
如果一个 SQL 语句中同时包含 `WHERE` 和 `ORDER BY`

那么先写 `WHERE` 再写 `ORDER BY`
====

排序语句，用来排序 `SELECT` 的结果，指定键名，以及对应的升序/降序模式， +
如果排序结果中有多行的值相同，则可指定更多的键名以作为 n 次排序。

比如

[source]
----
SELECT
    name,
    milliseconds,
    albumid
FROM
    tracks
ORDER BY
    albumid ASC;
----


=== DISTINCT 语句

[source]
----
SELECT DISTINCT <键名1>[, <键名2> ...]
FROM <表名>
----

对于指定的键名，仅返回互不相同的值 +
若指定了多个键名，则多个键名对应的值必须全部相同，才会被认为是“相同的值”。

对于 NULL，所有的 NULL 都会被认为是相同的。

比如

[source]
----
/*
查看有多少不同国家、不同城市的客户，
只有同时具有相同的城市名和国家名，才会被认为是相同的
*/

SELECT DISTINCT
    city,
    country
FROM
    customers
ORDER BY
    country,
    city;
----


=== WHERE 语句

[source]
----
SELECT
    ...
FROM
    ...
WHERE
    <搜索条件>;
----

预先筛选值

[NOTE]
====
除了 `SELECT` 语句，`WHERE` 还可以用于 `UPDATE` 和 `DELETE` 语句中
====

sqlite3 执行具有 `WHERE` 语句的 `SELECT` 语句遵循以下步骤

. 从 `FROM` 语句获取表
. 依照 `WHERE` 语句筛选表的内容
. 依照 `SELECT` 语句构成最终的结果

其中 <搜索条件> 语句为以下的形式

[source]
----
<左表达式> <比较操作符> <右表达式>
----

<搜索条件> 语句举例

[source]
----
-- 某列为某值
WHERE column_1 = 100;

-- 某列在某集合中
WHERE column_2 IN (1,2,3);

-- 某列可匹配某样式
WHERE column_3 LIKE 'An%';

-- 某列在某两个值之间
WHERE column_4 BETWEEN 10 AND 20;
----


[cols="^1m, ^1"]
.SQLite 的比较操作符
|===
| 操作符 | 含义

| =
| 等于

d| `<>` 或 `!=`
| 不等于

| <
| 小于

| >
| 大于

| \<=
| 小于等于

| >=
| 大于等于
|===

[IMPORTANT]
====
SQLite 不提供布尔值，因此，`1` 表示真，`0` 表示假。

SQLite 逻辑操作符会返回三种值 `1`、`0` 或者 `NULL`。
====

[cols="^1m, ^3, ^1"]
.SQLite 的逻辑操作符
|===
| 操作符 | 含义 | 简单记忆

| ALL
| 当且仅当所有表达式为 `1` 时，返回 `1`
| 全部

| ANY
| 当任意一个表达式为 `1` 时，返回 `1`
| 任意

| AND
| 当且仅当两个表达式均为 `1` 时，返回 `1`，否则返回 `0`
| 且

| OR
| 若两个表达式中有一个为 `1` 时，就返回 `1`
| 或

| NOT
| 对返回的结果取反
| 取反

| BETWEEN .. AND ..
| 当值处于某两个值（含）之间时，返回 `1`
| range()

| EXISTS
| 当自搜索包含任何列，就返回 `1`
| 存在

| LIKE
| 若能匹配样式
| glob
|===

=== LIMIT 语句

[TIP]
====
总的来说过，总是应该在排序（`ORDER BY`）之后，再限制输出长度和位置（`LIMIT`）
====

[source]
----
SELECT
    ...
FROM
    ...
LIMIT <行数>; #-- 将返回的行数限制为 <行数>
----

[source]
----
SELECT
    ...
FROM
    ...
LIMIT <行数> OFFSET <偏移行数>; -- 从结果头偏移指定行后，限制返回的行数
----

[source]
----
SELECT
    ...
FROM
    ...
LIMIT <偏移行数>, <限制行数> -- 上面的 LIMIT ... OFFSET ... 的简写形式
----

=== BETWEEN 语句

****
`BETWEEN` 是 `WHERE` 的子语句，必须在 `WHERE` 中使用。
****

[source]
----
<键名> [NOT] BETWEEN <最低值> AND <最高值>;
----

筛选值在（或不在）某个范围之间。

可用于 `SELECT` / `DELETE` / `UPDATE` / `REPLACE`

[IMPORTANT]
====
`BETWEEN` 所选定的范围是包含最低值和最高值本身的

由于 `BETWEEN` 是包含端值的，因此 `NOT BETWEEN` 就不包含端值了
====

[NOTE]
====
`BETWEEN` 可以产生的范围，除了数值范围之外，还可以接受日期/时间范围
====

[source]
.案例
----
/*
从 tracks 表中筛选 TrackId 在 10 到 20 之间的 track，
并显示它们的 TrackId、名称以及作家
*/

SELECT
    TrackId, Name, Composer
FROM
    tracks
WHERE
    TrackId BETWEEN 10 and 20;
----

=== IN 语句

****
`IN` 是 `WHERE` 的子语句，必须在 `WHERE` 中使用。
****

[source]
----
<键名> [NOT] IN (<枚举值1>[, <枚举值2> ...]);
----

用一系列枚举值筛选数据

[source]
----
-- 从 customs 表中查找国家为 Canada 和 Spain 的客户的名字和国籍
SELECT
    FirstName,LastName,Country
FROM customers
WHERE
    Country IN ('Canada', 'Spain') # 特别注意这里的双引号
ORDER BY
    Country;
----

上面的操作等价于

[source]
----
/*
从 customs 表中查找国家为 Canada 和 Spain 的客户的名字和国籍
但是使用 IS 和 OR 语法
*/

SELECT
    FirstName,LastName,Country
FROM
    customers
WHERE
    Country IS 'Canada' OR Country IS 'Spain' # IS 也可以用等号 = 代替
ORDER BY
    Country;
----

使用嵌套查找返回特定的数据

[source]
----
/*
查找 Queen 乐队唱过的歌
使用了两次子查找的返回值

这里有一个值的学习的地方，案例数据库中
不同的表之间是用各种 Id 关联上的，而非直接用值关联上
这样就让各种数据“解耦和”了。
*/

-- 最后通过 AlbumId 筛选出唱过的歌曲
SELECT
    Name
FROM
    tracks
WHERE
    -- 再通过 ArtistId，从 albums 表中找到属于他们的 AlbumId
    AlbumId IN (
        SELECT
            AlbumId
        FROM
            albums
        WHERE
            -- 先从 artists 表中找到 Queen 乐队的 ArtistId
            ArtistId IN (
                SELECT
                    ArtistId
                FROM
                    artists
                WHERE
                    Name IS 'Queen'
            )
    );
----

=== LIKE 语句

****
`LIKE` 是 `WHERE` 的子语句，必须在 `WHERE` 中使用。
****

[source]
----
<键名> LIKE <样式> [ESCAPE <指定的转义字符>]
----

`LIKE` 也可以用于 `UPDATE`、`DELETE` 等语句中

<样式> 支持两种模糊搜索符号

* 百分号 `%`，表示具有零个或多个字符的字符串
* 下划线 `_`，表示一个字符

与正则表达式不同，`LIKE` 语句是全匹配的， +
也就是说 `s%` 表示的是以 s 开头的值， +
比如 `s`、`so`、`sea` 都可以被匹配，但 `mass` 无法匹配上； +
`%es` 则表示以 `es` 结尾的值， +
比如 `es`、`likes`、`goes` 都可以被匹配，但 `especial` 就无法匹配上；
要匹配 `likes` 和 `especial`，可以使用 `%es%` 来表示。

[IMPORTANT]
====
默认情况下，`LIKE` 语句对于 ASCII 是大小写不敏感的，也就是说 `LIKE a` 和 `LIKE A` 是等价的。

如果要让 `LIKE` 语句大小写敏感，需要使用下方的 `PRAGMA` 语句进行设置

[source]
------
PRAGMA case_sensitive_like = true;
------
====

有时候，你可能需要匹配百分号字符 `%` 自身，以及下划线字符 `_` 自身，此时需要追加 `ESCAPE` 语句来指定一个转义字符。比如，

[source]
----
--- 匹配 share 列中，值为 10% 的行
share LIKE '10\%' ESCAPE '\';
----

=== GLOB 语句

[NOTE]
====
还是用 `REGEXP` 语法比较好
====

****
`GLOB` 是 `WHERE` 的子语句，必须在 `WHERE` 中使用。
****

[source]
----
<键名> GLOB <样式>
----

支持 UNIX GLOB 语法

=== REGEXP 语句

****
`REGEXP` 是 `WHERE` 的子语句，必须在 `WHERE` 中使用。
****

[source]
----
<键名> REGEXP <样式>
----

使用正则表达式筛选值

[NOTE]
====
由于此处的正则表达式仅用于查找，而非替换 +
因此不支持向前查找 `(?\<=...)` 以及向后查找 `(?=...)`
====

=== IS NULL 语句

[source]
----
<键名>|<其它表达式> IS [NOT] NULL
----

判定一个值是否为空

[IMPORTANT]
====
在 `IS` 判定中 `NULL IS NULL` 为假
====

=== JOIN 语句

从两个或更多的表中查找数据

由于 JOIN 有多个关联的语法，这里我们直接以案例讲解

[source]
.基础 INNER JOIN 语句
----
/*
由于 albums 表中的艺术家是用 ArtistId 表示的，
虽然它便于管理，但只打印 AristId 并不适合人类的观察
我们希望在打印专辑名的时候，同时打印艺术家的名称，
于是，我们可以使用 INNER JOIN 从两个表中抽取所需的值
*/

SELECT
    -- 由于 ArtistId 这个键名在 albums 和 artists 表中均出现了，
    -- 因此这里需要明确指出显示的是哪个表里的 ArtistId
    AlbumId, Title, Name, albums.ArtistId
FROM
    albums
-- INNER JOIN <要结合的表名>
INNER JOIN artists
    -- ON <筛选依据>
    -- 用来设置一个匹配依据，当第一个表的指定列的值与第二个表的指定列的值匹配时，才将这两个行列举为一个
    -- 下面说的是：若 artists 表中的一行的 ArtistId 值与 albums 表中的一行的  ArtistId 值相同时，将两者和为一行
    ON artists.ArtistId = albums.ArtistId
ORDER BY
    artists.ArtistId,
    albums.AlbumId
LIMIT
    20;
----

[source]
.表格的临时名称
----
/*
由于要 join 的两个表的名称会反复出现，
因此我们可以为表设置一个临时的名称，方便指代
*/

SELECT
    AlbumId, Title, Name, r.ArtistId
FROM
    -- 这里我们手动定义 albums 表的临时名称为 l
    albums l
-- 这里我们手动定义 artists 表的临时名称为 r
INNER JOIN artists r
    ON r.ArtistId = l.ArtistId
ORDER BY
    r.ArtistId,
    l.AlbumId
LIMIT
    20;
----

[source]
.同键名匹配的简写
----
/*
由于我们要匹配的键的键名是相同的（ArtistId），
于是匹配规则还可以如下简写
*/

SELECT
    AlbumId, Title, Name, r.ArtistId
FROM
    albums l
-- 使用 USING() 表示我们要匹配的是
INNER JOIN artists r USING(ArtistId)
ORDER BY
    r.ArtistId,
    l.AlbumId
LIMIT
    20;
----

内合并（`INNER JOIN`）与外合并（`OUTER JOIN`）

我们在匹配两个表的时候，并不能保证两个表的指定键的所有值刚好是完全匹配的， +
举例来说，比如一张专辑可能没有记录艺术家，或者一个艺术家目前还没有创建任何一张专辑， +
对于这种情况，SQL 语句支持以下几种合并方案：

* 内合并（`INNER JOIN`） +
也是 `JOIN` 的默认形式，仅返回能匹配的行，而丢弃两张表种任何无匹配的行 +
简单理解，其表示两个表的交集
* 外合并（`OUTER JOIN`） +
等价于某种非交集的操作
** 左外合并（`LEFT OUTER JOIN`） +
即便左侧的表（`FROM` 语句跟随的表）的值无法与任何右侧的表（`LEFT OUTER JOIN` 语句跟随的表）的值匹配，也一同保留下来， +
此时右侧表的值填充为 `NULL`
** 右外合并（`RIGHT OUTER JOIN`） +
即便右侧的表（`RIGHT OUTER JOIN` 语句跟随的表）的值无法与任何左侧的表（`FROM` 语句跟随的表）的值匹配，也一同保留下来， +
此时左侧表的值填充为 `NULL`
** 全外合并（`FULL OUTER JOIN`） +
保留两侧表中任何不匹配的行，对无值的部分填充 `NULL`

[NOTE]
====
上述内容中的“左侧表格”为 `FROM` 语句引入的表格； +
上述内容中的“右侧表格”为各种 `JOIN` 语句引入的表格
====

上面的四种合并方式有如下的简写关系

* `INNER JOIN` -> `JOIN`
* `LEFT OUTER JOIN` -> `LEFT JOIN`
* `RIGHT OUTER JOIN` -> `RIGHT JOIN`
* `FULL OUTER JOIN` -> `FULL JOIN`

除了上述的匹配型合并，还有一种交叉合并（`CROSS JOIN`）

交叉合并不进行任何匹配过程，直接将左侧的每一行与右侧的每一个行进行合并

假设左侧有 N 行，而右侧有 M 行，则生成的新表格有 N*M 行

[source]
.生成两年的月历
----
/*
注意我们会通过 `TEMPORARY` 语法创建临时的表，
它等价于在内存中创建名为 `temp` 的数据库，然后将所有被标记为临时的表放在这个数据库中，
这样，读写这个数据库不会有磁盘 IO 操作，而且退出这个 sqlite 会话后，表的内容会一同丢弃。
*/

-- 如果你之前有打开任何数据库
-- .open ''

-- 创建临时的年列表
CREATE TEMPORARY TABLE Year(
    Year INTEGER
);

INSERT INTO
    Year(Year)
VALUES
    (2023),(2024);

-- 创建临时的月列表
CREATE TEMPORARY TABLE Month(
    Month TEXT
);

INSERT INTO
    Month(Month)
VALUES
    ('Jan'), ('Feb'), ('Mar'), ('Apr'), ('May'), ('Jun'), ('Jul'), ('Aug'), ('Sep'), ('Oct'),('Dec'),('Nov');

-- 创建最终月历
CREATE TABLE Calendar(
    Year INTEGER,
    Month TEXT
);

-- 使用 CROSS JOIN 生成月历表
INSERT INTO
    Calendar(Year, Month)
SELECT
    *
FROM
    Year
CROSS JOIN
    Month;
----

在 JOIN 的用法中，有一种比较特殊的用法，被称为自结合（self-join）， +
若一个表格的某一列的值会指向该表格的另一列，那么自结合就有作用

[source]
.从职员表中提取上下级关系
----
/*
employees 表中，有两个列，
一个是 EmployeeId，也就是每个员工的 Id，
另一个是 ReportsTo，是该行员工需要汇报的员工的 Id（上级），
这样我们就可以通过自结合，列举出每个员工的上下级关系
*/

-- 由于是自结合，因此使用临时表名是必然的
SELECT
-- 双竖线表示文本串联，这里表示的是生成一个人的全名
-- 这里用 AS 重命名一下表头
    m.FirstName || ' ' || m.LastName AS 'Manager',
    r.FirstName || ' ' || r.LastName AS 'Reporter'
FROM
    employees r
-- 由于有些人没有报告对象（比如顶层管理人员不需要向其他人报告）
-- 这里用 LEFT JOIN，保留全体 EmployeeId，当 ReportsTo 空缺时，填充 NULL
LEFT JOIN
    employees m
    ON
        m.EmployeeId = r.ReportsTo
ORDER BY
    -- 排序是在新表生成之后执行的，
    -- 因此这里的列名应该是 AS 后指定的名称
    Manager;
----

=== GROUP BY 语法

按照指定的条件，将多行打组，并“压缩”为一行，

默认情况下，“压缩”的方式为仅取每组的第一行的值，比如

[source]
.在 GROUP BY 下 SELECT 的默认行为
----
SELECT
    TrackId, Name
FROM
    tracks
GROUP BY
    AlbumId;
----

就把每个专辑的第一首歌的编号和歌名显示了出来。

看起来实在是没啥意义。

所以，一旦使用了 `GROUP BY`，通常情况下，还会使用一些 SQL 提供的函数进行“统计”操作。

[source]
.将 GROUP BY 与统计函数结合使用
----
/*
显示了一个专辑的专辑 Id、专辑名、专辑中歌曲的数量、以及歌曲的名称
*/

SELECT
    AlbumId,
    albums.Title AS 'Album Title',
    -- COUNT() 函数，用来统计一个组中符合条件的行的数量
    -- COUNT(*) 则直接统计一个组中所有行的数量
    COUNT(*) AS 'Track Count',
    -- GROUP_CONCAT() 函数，将一个组中每一行的指定列合并为一个值
    -- 下方的用法说的是，将 Name 列的值合并，而且使用回车作为每个值的间隔
    -- 注意，回车不能使用 \n 表示，可以实际在单引号中敲入一个回车，或者使用 x'0a'（回车的 ASCII），或者 char(10)
    GROUP_CONCAT(Name, x'0a') AS 'Track Title'
FROM
    tracks
INNER JOIN
    albums
        USING(AlbumId)
-- 以 AlbumId 作为打组依据
GROUP BY
    AlbumId
LIMIT 20;
----

[source]
.双打组
----
/*
以国家和城市将客户打组
*/
SELECT
    Country,
    City,
    GROUP_CONCAT(FirstName || ' ' || LastName, x'0a') AS "Name"
FROM
    customers
-- 双打组，
--- Country 和 City 均相同的行才会被归类在一组里
GROUP BY
    Country,
    City;
----

=== HAVING 语句

对组进行筛选

[source]
.HAVING 语句的基本语法
----
/*
接着上面的例子，从结果中筛选单专辑中含有的歌曲数量介于 5 和 10 之间的专辑
*/

SELECT
    AlbumId,
    albums.Title AS 'Album Title',
    COUNT(*) AS 'Track Count',
    GROUP_CONCAT(Name, x'0a') AS 'Track Title'
FROM
    tracks
INNER JOIN
    albums
        USING(AlbumId)
GROUP BY
    AlbumId
HAVING
    -- 特别注意，由于这里的列标识符含有空格，因此必须使用双引号包裹
    -- 特别注意，不可以使用单引号，单引号表示的是字符串字面量，
    -- 使用单引号不会报任何错误，但会导致筛选错误
    "Track Count" BETWEEN 5 AND 10;
----

=== UNION 语法

将来自两个表的行合并为一个表（并集）

[source]
----
<查询1>
UNION [ALL]
<查询2>
...;
----

`UNION` 会执行行去重，而 `UNOIN ALL` 不会

要成功执行 `UNION` 操作，被合并的两个表必须具有以下特征：

* 所有查询返回的表的列数必须相同
* 两个返回的表的对应的列的数据类型应该是相互兼容的

`UNION` 操作还有如下特点：

* 第一个查询的列名称确定了合并的表的列名称
* `GROUP BY` 和 `HAVING` 是针对每个查询施加的，而非对合并的结果施加
* `ORDER BY` 是对合并的结果施加的，而非针对每个查询施加的

[source]
.UNION 的基础语法
----
/*
将客户和雇员的姓名合并在一个表里，并分别为他们附注人员类别
*/

SELECT
    FirstName,
    LastName,
    -- 如果我们要对某个列填充一个值
    -- 直接再 SELECT 中输入这个值就好了
    -- 记得用单引号包裹起来
    'Employee' AS Type
FROM
    employees
UNION
SELECT
    FirstName,
    LastName,
    'Customer'
FROM
    customers
ORDER BY
    -- 由于 Type 是关键字，这里我们必须用双引号将其包裹
    -- 表明这里是列的名称，并非关键字
    "Type",
    FirstName,
    LastName;
----

=== EXCEPT 语句

类似 `UNION` 语句，但求取的是第一个查询和第二个查询的差集

[IMPORTANT]
====
仅当第一个查询的某一行的**所有列**完全匹配第二查询的某一行的**所有列**时，才会被移除
====

[source]
.EXCEPT 基础语法
----
/*
查询有哪些艺术家没有出过专辑
*/

SELECT
    ArtistId,
    Name
FROM
    artists
WHERE
    ArtistId IN (
        -- 由于 EXCEPT 是全匹配的，
        -- 因此这里只能筛选 ArtistId 这列
        -- 与艺术家名的匹配只能放到外侧实现了
        SELECT
            ArtistId
        FROM
            artists
        EXCEPT
        SELECT
            ArtistId
        FROM
            albums
    );
----

=== INTERSECT 语句

类似 `EXCEPT` 语句，但求的是两个查询的交集

=== EXIST 语句

返回一个子查找是否返回了任何行

[source]
----
[NOT] EXIST(子查找)
----
